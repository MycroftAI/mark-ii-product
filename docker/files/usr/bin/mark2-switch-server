#!/usr/bin/env python3
import asyncio
import argparse
import functools
import json
import logging
import socket
import threading
import time
from pathlib import Path
from typing import Any, Dict, List, Optional

import RPi.GPIO as GPIO
from websockets import connect

_LOGGER = logging.getLogger("mark2-switch-server")

# sj201Rev4
PINS = {"volume_up": 22, "volume_down": 23, "action": 24, "mute": 25}

DEBOUNCE = 100
WAIT_SEC = 0.05
ACTIVE = 0

SWITCH_ON = "on"
SWITCH_OFF = "off"


async def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--uri",
        default="ws://127.0.0.1:8181/core",
        help="URI of websocket messagebus",
    )
    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO)

    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

    loop = asyncio.get_running_loop()
    event_queue = asyncio.Queue()
    for name, pin in PINS.items():
        GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.add_event_detect(
            pin,
            GPIO.BOTH,
            callback=functools.partial(handle_event, name, pin, event_queue, loop),
            bouncetime=DEBOUNCE,
        )

    async with connect(args.uri) as websocket:
        message: Optional[Dict[str, Any]] = None
        while True:
            try:
                if websocket is None:
                    # Reconnect
                    _LOGGER.warning("Reconnecting to %s", args.uri)
                    websocket = await connect(args.uri)

                if message is not None:
                    message_str = json.dumps(message, ensure_ascii=False)
                    await websocket.send(message_str)
                    message = None

                name, state = await event_queue.get()
                _LOGGER.debug("%s: %s", name, state)

                message = {
                    "type": "mycroft.switch.state",
                    "data": {"name": name, "state": state},
                }
            except Exception:
                websocket = None
                _LOGGER.warning("Waiting to reconnect...")
                time.sleep(5)
            except KeyboardInterrupt:
                break


def handle_event(
    name, pin, event_queue: asyncio.Queue, loop: asyncio.AbstractEventLoop, _channel
):
    time.sleep(WAIT_SEC)
    value = GPIO.input(pin)
    state = SWITCH_ON if value == ACTIVE else SWITCH_OFF
    loop.call_soon_threadsafe(event_queue.put_nowait, (name, state))


if __name__ == "__main__":
    asyncio.run(main())
