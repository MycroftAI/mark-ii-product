#!/usr/bin/env python3
# Copyright 2022 Mycroft AI Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# -----------------------------------------------------------------------------
#
# Sets the LEDs on the Mark II to the specified colors.
#
# Example: mark2-leds R1 G1 B1 R2 G2 B2 ...
#
# Colors are cycled if missing, so R1 G1 B1 R2 G2 B2 will be
# R1 G1 B1 R2 G2 B2 R1 G1 B1 R2 G2 B2 ... for all LEDs.

import itertools
import subprocess
import sys

BUS_ID = 1
DEVICE_ADDRESS = 0x04

MAX_COLOR = 255
MIN_COLOR = 0
NUM_COLORS = 3

NUM_LEDS = 12
FIRST_LED = 0
MAX_LEDS_PER_WRITE = 10


def main():
    """Main entry point"""

    # r1 g1 b1 r2 g2 b2 ...
    values = [min(MAX_COLOR, max(MIN_COLOR, int(arg))) for arg in sys.argv[1:]]

    # Default to black if no arguments
    values = values or [MIN_COLOR]

    # Ensure a full triplet
    while (len(values) % NUM_COLORS) != 0:
        values.append(MIN_COLOR)

    # Repeat color for all leds, if necessary
    rgb = list(itertools.islice(itertools.cycle(values), 0, NUM_LEDS * NUM_COLORS))

    # Write in blocks to avoid overloading i2cset
    last_value = MAX_LEDS_PER_WRITE * NUM_COLORS
    write_offset = 0
    while rgb:
        set_command = [
            "i2cset",
            "-y",  # disable interactive mode
            "-a",  # allow access to LED device range
            str(BUS_ID),
            f"0x{DEVICE_ADDRESS:02x}",
            f"0x{FIRST_LED + write_offset:02x}",
            *(str(value) for value in rgb[:last_value]),
            "i",  # block data
        ]

        subprocess.check_call(set_command)

        # Next block
        rgb = rgb[last_value:]
        write_offset += MAX_LEDS_PER_WRITE


if __name__ == "__main__":
    main()
